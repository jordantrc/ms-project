# test_network.py
#
# Tests the model checkpoints with the
# test data from test tfrecord files
#

import itertools
import os
import tensorflow as tf
import c3d
import c3d_model
import sys
import numpy as np
import matplotlib

matplotlib.use('Agg')

import matplotlib.pyplot as plt
from sklearn import metrics

from train_network_images import get_image_batch


CLASS_LIST = "/home/jordanc/datasets/UCF-101/classInd.txt"
NUM_CLASSES = 101
BATCH_SIZE = 10
TEST_SPLIT = "train-test-splits/test.list"
TEST_IMAGE_CROPPING = 'center'
IMAGE_NORMALIZATION = True


def tf_confusion_matrix(predictions, labels, classes):
    """
    produces and returns a confusion matrix given the predictions generated by
    tensorflow (in one-hot format), and string labels.
    """
    # print("pred = %s, type = %s, labels = %s, type = %s, classes = %s, type = %s" % (predictions, type(predictions), labels, type(labels), classes, type(classes)))

    y_true = []
    y_pred = []

    for p in predictions:
        pred = p[0]
        y_true.append(classes[pred])

    for l in labels:
        label = l[0]
        y_pred.append(classes[label])

    cm = metrics.confusion_matrix(y_true, y_pred, classes)

    return cm


def plot_confusion_matrix(cm, classes, filename,
                          normalize=True,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    thresh = cm.max() * 0.73
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, "{0:.4f}".format(cm[i, j]),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")
    plt.tight_layout()
    plt.ylabel('True class')
    plt.xlabel('Predicted class')
    plt.savefig(filename)
    plt.gcf().clear()
    plt.cla()
    plt.clf()
    plt.close()


# specify a model to load or use the default
if len(sys.argv) == 3:
    run_name = sys.argv[1]
    model_to_load = sys.argv[2]
else:
    print("Provide run name and model")
    sys.exit(1)

# get the list of class names
class_names = []
with open(CLASS_LIST) as class_fd:
    text = class_fd.read()
    lines = text.split("\n")
    for l in lines:
        if len(l) > 0:
            i, c = l.split(" ")
            class_names.append(c)

assert len(class_names) == NUM_CLASSES

model = c3d_model.C3DModel()

run_log_file = 'runs/test_%s.log' % run_name
run_log_fd = open(run_log_file, 'w', 0)
run_log_fd.write("run name = %s" % run_name)

with tf.Session() as sess:
    coord = tf.train.Coordinator()
    threads = tf.train.start_queue_runners(coord=coord)
    weights, biases = c3d.get_variables(model.num_classes)

    x = tf.placeholder(tf.float32, shape=[BATCH_SIZE, model.frames_per_clip, 112, 112, 3])

    logits = model.inference_3d(x, weights, biases, BATCH_SIZE, False)
    y_pred = tf.nn.softmax(logits)
    y_pred_class = tf.argmax(y_pred, axis=1)

    init_op = tf.global_variables_initializer()

    # restore the model
    saver = tf.train.Saver()
    saver.restore(sess, model_to_load)
    print("Restored model %s" % model_to_load)

    # test a single run through of the test data
    sess.run(init_op)

    step = 0
    cumulative_accuracy = 0.0
    _, _, _, num_samples = get_image_batch(TEST_SPLIT, BATCH_SIZE, model.frames_per_clip, model.num_classes)
    offset = 0
    predictions = []
    labels = []
    run_log_fd.write("true_class,predicted_class,hit_at_5")
    while step < int(num_samples / BATCH_SIZE):
        x_feed, y_feed, offset, _ = get_image_batch(TEST_SPLIT, BATCH_SIZE, model.frames_per_clip, model.num_classes,
                                                    offset=offset, crop=TEST_IMAGE_CROPPING, normalize=IMAGE_NORMALIZATION,
                                                    shuffle=False)
        y_pred_out, hit_5_out = sess.run([y_pred, hit_5], feed_dict={x: x_feed, y_true: y_feed, learning_rate: model.current_learning_rate})

        for i in range(BATCH_SIZE):
            run_log_fd.write("%s,%s,%s" % (y_feed[i], np.argmax(y_pred_out[i]), hit_5_out[i]))
            print("true class = %s, prediction = %s, hit@5 = %s" % (y_feed[i], np.argmax(y_pred_out[i]), hit_5_out[i]))
        step += 1
    
    print("Exhausted test data")
    print("Cumulative accuracy = %s" % (cumulative_accuracy / step))
    print("Confusion matrix =")
    cm = tf_confusion_matrix(predictions, labels, class_names)
    plot_confusion_matrix(cm, class_names, "confusion_matrix.pdf")
